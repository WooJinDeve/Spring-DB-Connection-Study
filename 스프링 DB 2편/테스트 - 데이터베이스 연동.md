# 테스트 - 데이터베이스 연동

## 테스트 데이터 베이스

- `@SpringBootTest` 는 `@SpringBootApplication` 를 찾아서 설정으로 사용한다
- 로컬에서 사용하는 애플리케이션 서버와 테스트에서 같은 데이터베이스를 사용하고 있으니 테스트에서 문제가 발생한다.
- 이런 문제를 해결하려면 테스트를 다른 환경과 철저하게 분리해야 한다.
- **데이터베이스를 용도에 따라 2가지로 구분**
    - `jdbc:h2:tcp://localhost/~/test` : local에서 접근하는 서버 전용 데이터베이스
    - `jdbc:h2:tcp://localhost/~/testcase` : test 케이스에서 사용하는 전용 데이터베이스
- **접속 정보 변경**
    - 이제 접속 정보를 변경하자  `main` 에 있는 `application.properties` 는 그대로 유지하고, `test` 에 있는 `application.properties` 만 변경해야 한다.

```java
spring.profiles.active=test
spring.datasource.url=jdbc:h2:tcp://localhost/~/testcase
spring.datasource.username=sa
```

## 테스트 - 데이터 롤백

- 테스트 실행 직전에 트랜잭션을 시작하고, 각각의 테스트 실행 직후에 트랜잭션을 롤백해야 한다. 그래야 다음 테스트에 데이터로 인한 영향을 주지 않는다.
- **테스트의 중요한 원칙**
    - 테스트는 다른 테스트와 격리해야 한다.
    - 테스트는 반복해서 실행할 수 있어야 한다.

```java
@SpringBootTest
class ItemRepositoryTest {

    @Autowired
    ItemRepository itemRepository;

    @Autowired
    PlatformTransactionManager transactionManager;

    TransactionStatus status;

    @BeforeEach
    void beforeEach(){
        // 트랜잭션 시작
        status = transactionManager.getTransaction(new DefaultTransactionDefinition());
    }

    @AfterEach
    void afterEach() {
        //MemoryItemRepository 의 경우 제한적으로 사용
        if (itemRepository instanceof MemoryItemRepository) {
            ((MemoryItemRepository) itemRepository).clearStore();
        }
        //트랜잭션 롤백
        transactionManager.rollback(status);
    }
}
```

- 트랜잭션 관리자는 `PlatformTransactionManager` 를 주입 받아서 사용하면 된다. 참고로 스프링 부트는 자동으로 적절한 트랜잭션 매니저를 스프링 빈으로 등록해준다

## @Transactional

- `@Transactional`이 테스트에 있으면 스프링은 테스트를 트랜잭션 안에서 실행하고, **테스트가 끝나면 트랜잭션을 자동으로 롤백 시킨다.**
![Untitled](https://user-images.githubusercontent.com/106054507/190154391-9840dcdd-2cfd-4333-940f-7da195088dd6.png)


1. 테스트에 `@Transactional` 애노테이션이 테스트 메서드나 클래스에 있으면 먼저 트랜잭션을 시작한다.
2. 테스트를 로직을 실행한다. 테스트가 끝날 때 까지 모든 로직은 트랜잭션 안에서 수행된다. 
    1. 트래잭션은 기본적으로 전파되기 때문에, 리포지토리에서 사용하는 `JdbcTemplate`도 같은 트랜잭션을 사용한다.
3. 테스트 실행 중에 `INSERT SQL`을 사용해서 `item1` , `item2` , `item3` 를 데이터베이스에 저장한다.
    1.  물론 테스트가 리포지토리를 호출하고, 리포지토리는 `JdbcTemplate`을 사용해서 데이터를 저장한다.
4. 검증을 위해서 `SELECT SQL`로 데이터를 조회한다. 
    1. `SELECT SQL`도 같은 트랜잭션을 사용하기 때문에 저장한 데이터를 조회할 수 있다. 다른 트랜잭션에서는 해당 데이터를 확인할 수 없다.
5. `@Transactional` 이 테스트에 있으면 테스트가 끝날때 트랜잭션을 강제로 롤백한다.
6. 롤백에 의해 앞서 데이터베이스에 저장한 `item1` , `item2` , `item3` 의 데이터가 제거된다

## 임베디드 모드 DB

- `H2 데이터베이스`는 자바로 개발되어 있고, `JVM`안에서 메모리 모드로 동작하는 특별한 기능을 제공한다.
- 애플리케이션을 실행할 때 `H2 데이터베이스`도 해당 `JVM 메모리`에 포함해서 함께 실행할 수 있다.
- `DB`를 애플리케이션에 내장해서 함께 실행한다고 해서 `임베디드 모드(Embedded mode)`라 한다.
- 애플리케이션이 종료되면 임베디드 모드로 동작하는 H2 데이터베이스도 함께 종료되고, 데이터도 모두 사라진다.

```java
@Slf4j
@Import(JdbcTemplateV3Config.class)
@SpringBootApplication(scanBasePackages = "hello.itemservice.web")
public class ItemServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(ItemServiceApplication.class, args);
	}

	@Bean
	@Profile("test")
	public DataSource dataSource(){
		log.info("메모리 데이터베이스 초기화");
		DriverManagerDataSource dataSource = new DriverManagerDataSource();
		dataSource.setDriverClassName("org.h2.Driver");
		dataSource.setUrl("jdbc:h2:mem:db;DB_CLOSE_DELAY=-1");
		dataSource.setUsername("sa");
		dataSource.setPassword("");
		return dataSource;
	}
}
```

- `dataSource()`
    - `jdbc:h2:mem:db` : 이 부분이 중요하다. 데이터소스를 만들때 이렇게만 적으면 임베디드 모드(메모리 모드)로 동작하는 H2 데이터베이스를 사용할 수 있다.
    - `DB_CLOSE_DELAY=-1` : 임베디드 모드에서는 데이터베이스 커넥션 연결이 모두 끊어지면 데이터베이스도 종료되는데, 그것을 방지하는 설정이다.
    - 이 데이터소스를 사용하면 메모리 DB를 사용할 수 있다.
- `application.properties 설정`
    - `src/test/resources/schema.sql`
    
    ```java
    drop table if exists item CASCADE;
    create table item
    (
        id        bigint generated by default as identity,
        item_name varchar(10),
        price     integer,
        quantity  integer,
        primary key (id)
    );
    ```
    

## 스프링 부트와 임베디드 모드

- 스프링 부트는 데이터베이스에 대한 별다른 설정이 없으면 임베디드 데이터베이스를 사용한다.
- 임베디드 데이터베이스 이름을 스프링 부트가 기본으로 제공하는 `jdbc:h2:mem:testdb` 로 고정 → `application.properties` 설정 추가

```java
spring.datasource.generate-unique-name=false
```
